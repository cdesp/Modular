
;FILL AN AREA AROUND POINT X,Y
;BOTH PARAMS ON STACK
;COLOR TO FILL FCOLOR
;AREA BOUNDS BY BCOLOR       
;RECURSION METHOD USES A LOT OF STACK
;SELF CLEANING PARAMS FROM STACK
@LCD_FILL_SP:
         LD IX,2
         ADD IX,SP         
         ;check current pixel is old_color or not 
         ;if (getpixel(x, y) == old_col) { 
         ;my change we paint all colors except bcolor
         ;if (getpixel(x, y) != BCOLOR) {
         LD H,(IX+3)
         LD L,(IX+2)
         PUSH HL
         LD H,(IX+1)
         LD L,(IX+0)
         PUSH HL         
         CALL LCD_READPIXEL
         EX DE,HL
         LD HL,(BCOLOR)         
         XOR A
         SBC HL,DE
         JR Z,FLEXIT  ;COMPARE WITH BCOLOR AND EXIT BOUNDS REACHED
         LD HL,(FCOLOR)         
         XOR A
         SBC HL,DE
         JR Z,FLEXIT  ;COMPARE WITH FCOLOR AND EXIT  WE ALREADY PLOT THIS         
         ;// put new pixel with new color 
         ;putpixel(x, y, new_col); 
         LD D,(IX+3)   ;X
         LD E,(IX+2)
         LD H,(IX+1)   ;Y
         LD L,(IX+0)
				 CALL PLOTP
         ;// recursive call for bottom pixel fill 
        ;flood(x + 1, y, new_col, old_col); 
         PUSH IX
         LD D,(IX+3)   ;X
         LD E,(IX+2)
         LD H,(IX+1)   ;Y
         LD L,(IX+0)
         INC DE                  
         PUSH DE
         PUSH HL
         EX DE,HL  ;HL=X
         LD DE,LCD_WIDTH
         XOR A
         SBC HL,DE
         JP C,FL_OK1
         POP HL  ;GET 3 PARAMS OFF STACK
         POP HL
         POP HL         
         JR FLEXIT
FL_OK1:  CALL LCD_FILL                 
         POP IX
        ;// recursive call for top pixel fill 
        ;flood(x - 1, y, new_col, old_col); 
         PUSH IX
         LD D,(IX+3)   ;X
         LD E,(IX+2)
         LD H,(IX+1)   ;Y
         LD L,(IX+0)
         DEC DE
         PUSH DE
         PUSH HL         
         CALL LCD_FILL                 
         POP IX  
        ;// recursive call for right pixel fill 
        ;flood(x, y + 1, new_col, old_col); 
         PUSH IX
         LD D,(IX+3)   ;X
         LD E,(IX+2)
         LD H,(IX+1)   ;Y
         LD L,(IX+0)
         INC HL
         PUSH DE
         PUSH HL
         CALL LCD_FILL                 
         POP IX
        ;// recursive call for left pixel fill 
        ;flood(x, y - 1, new_col, old_col); 				          
         PUSH IX
         LD D,(IX+3)   ;X
         LD E,(IX+2)
         LD H,(IX+1)   ;Y
         LD L,(IX+0)
         DEC HL
         PUSH DE
         PUSH HL         
         CALL LCD_FILL                 
         POP IX
         
FLEXIT:  POP DE ;GET RET ADDR
         LD HL,2*2       ;REMOVE PARAMS FROM STACK
         ADD HL,SP     ;
         LD SP,HL 
         EX DE,HL     
         JP (HL)
                           
;
@LCD_PRINTCHAR:
      ;A THE CHAR TO BE PRINTED ON CURSORX AND CURSORY
      ;SETXY(CURSORX*FONT_WIDTH,CURSORY*FONT_HEIGHT,(CURSORX+1)*FONT_WIDTH,(CURSORY+1)*FONT_HEIGHT)
      ;FONT_PATTERN = B=FONT_ADDR  C=A FOR EACH FONT LINE JUST INCREASE B
      CP 0X08   ;BACKSPACE
      JP Z,PRCH_DOBCKSPC
      CP 0X0A   ;LINE FEED JUST IGNORE IT
      RET Z
      CP 0X0D   ;CHECK FOR ENTER
      JR NZ,PRCH_DOPRN
      LD HL,CURSORX
      JP PRCH_NEWLN 
PRCH_DOBCKSPC:
      LD HL,CURSORX      
      LD A,(HL)
      JR C,DOREALBCKSPC
      ;IF C IS NOT SET THEN GO LEFT
      CP 1      ;COMPARE WITH COLUMN 1 CAUSE OF THE PROMPT ON COLUMN 0
      RET Z
      DEC (HL)
      RET      
DOREALBCKSPC:
      CP 1      ;COMPARE WITH COLUMN 1 CAUSE OF THE PROMPT ON COLUMN 0
      JR Z,PRCH_DOBCKSPC2     ;IF 0 WE ARE ON THE 1ST COLUMN SO NOTHING TO DO JUST DELETE THE 8=BS FROM BUFFER
      DEC (HL)  ;GO 1 POSITION BACK
      PUSH HL
      LD A,32   ;PRINT SPACE
      CALL PRCH_DOPRN ;THIS FORWARDS THE CURSOR SO WE SHOULD GO BACK AGAIN
      POP HL
      DEC (HL)  ;GO 1 POSITION BACK
      OR A      
      ;NOW DELETE FROM THE BASIC BUFFER TOO
      ;BS =8 ALREADY PUT ON BUFFER SO WE SHOULD GO BACK 2 PLACES
PRCH_DOBCKSPC2:
      LD IX,2
      ADD IX,SP
      LD H,(IX+1);POSITION IN ACCS FOR THE NEW CHARACTER      
      LD L,(IX) ;POSITION IN ACCS FOR THE NEW CHARACTER  
      LD A,0    ;NOT XOR WE DONT WANT TO MESS WITH ZERO FLAG
      JR Z,PRCH_SKIP1  ;WE ARE ON COLUMN 1
      DEC HL     ;PREVIOUS POSITION DELETE BACKSPACE
      LD (HL),A  ;PUT 0 ON LAST POSITION
PRCH_SKIP1:      
      DEC HL     ;PREVIOUS POSITION DELETE PREVIOUS CHAR
      LD (HL),A  ;PUT 0 ON LAST POSITION      
      LD (IX+1),H ;PUT POSITION BACK ON STACK IT WILL POPED
      LD (IX),L
      RET
                  
PRCH_DOPRN:
      PUSH AF  ;SAVE CHAR TO STACK
      LD (LASTCHAR),A ;SAVE LAST PRINTED CHAR
      LD A,(CURSORX)
      LD B,FONT_WIDTH
      LD D,0
      LD E,A
      LD HL,0
      OR A          ; CLEAR CARRY
PRCH_AGN1:
      ADC HL,DE
      DJNZ PRCH_AGN1 ;HL=DE*B
      PUSH HL       ;1ST PARAM X1
      LD DE,FONT_WIDTH 
      ADC HL,DE      
      DEC HL
      PUSH HL       ;SAVE 3RD PARAM X2
      LD A,(CURSORY)
      LD B,FONT_HEIGHT 
      LD D,0
      LD E,A
      LD HL,0
PRCH_AGN2:
      ADC HL,DE
      DJNZ PRCH_AGN2      
      POP DE        ;RETREIVE 3RD PARAM X2
      PUSH HL       ;2ND PARAM Y1
      PUSH DE       ;3RD PARAM X2
      LD DE,FONT_HEIGHT
      ADC HL,DE     ;CALC 4TH PARAM      
      DEC HL        ;4TH PARAM -1  
      PUSH HL				;4TH PARAM Y2
      CALL LCD_SETXY
      POP AF        ;CHAR TO PRINT FROM STACK
      LD HL,FONT_ADDR
      LD D,0
      LD E,A
      ADC HL,DE     ;THIS IS THE CHAR ADDRESS
      PUSH HL
      POP DE        ; CHAR ADDRESS ON DE
      LD C,FONT_HEIGHT   ; TOTAL FONT LINES
PRCH_AGN3:      
      LD A,(DE)           ;FONT 8BIT PATTERN FOR A LINE
      LD B,FONT_WIDTH      
PRCH_AGN4:      
      SLA A               ;CHECK BIT FOR 1=FCOLOR OR 0=BCOLOR
      JR C,FORECOLOR
      LD HL,(BCOLOR)
      JR PRCH_CONT
FORECOLOR:
      LD HL,(FCOLOR)      
PRCH_CONT:
      PUSH AF
      PUSH DE             ;TODO:PROBABLY NOT NEEDED HERE 
      CALL LCD_SETPIXEL
      POP DE
      POP AF      
      DJNZ PRCH_AGN4
      INC D             ;ADD 256 FOR NEXT CHAR PATTERN
      DEC C
      JR NZ,PRCH_AGN3
      ;FORWARD CURSOR
      LD HL,CURSORX
      LD A,(HL)
      INC A
      CP 80
      JR Z,PRCH_NEWLN  ;NEW LINE
      LD (HL),A
      RET
         
PRCH_NEWLN:
      XOR A  
      LD (HL),A   
      INC HL
      LD A,(HL)
      INC A       
      ;CHECK FOR END OF SCREEN
      CP 47         ;47 LINES MAX THEN WRAP OR BETTER SCROLL THE SCREEN!!!
      JR NZ,PRCH_NOTYET
      XOR A
PRCH_NOTYET:
      LD (HL),A                             
      RET
;
@LCD_RMVCURS:
      ;REMOVES THE CURSOR FROM PREVIOUS POSITION
   ;   LD A,(CURSORX)
   ;   LD H,A
   ;   LD A,(CURSORY)
   ;   LD L,A
   ;   PUSH HL             ;SAVE CURSOR
   ;   LD A,(PRECSRX)     ;REPLACE CURSX AND Y WITH THE PREVIOUS ONES
   ;   LD (CURSORX),A
   ;   LD A,(PRECSRY)
   ;   LD (CURSORY),A
      LD HL,(BCOLOR);      
      JR LCD_SETCURS
   ;   POP HL              ;LOAD CURSOR
   ;   LD A,H
   ;   LD (CURSORX),A
   ;   LD A,L
   ;   LD (CURSORY),A
    ;  RET
      

@LCD_PRNCURS:     
      ;ADD A CURSOR ON NEW POSITION
      LD HL,(FCOLOR)      ;COLOR PARAM      
      
@LCD_SETCURS:
      PUSH HL             ;COLOR PARAM
      LD A,(CURSORX)
      LD B,FONT_WIDTH
      LD D,0
      LD E,A
      LD HL,0
      OR A                ;CLEAR CARRY
SCUR_AGN1:
      ADC HL,DE
      DJNZ SCUR_AGN1      ;HL = DE * B 
      PUSH HL             ;1ST PARAM X1
      LD BC,FONT_WIDTH
      ADC HL,BC           ;NEXT CHAR
      DEC HL              ;MINUS 1
      PUSH HL             ;SAVE 3RD PARAM X2      
      LD A,(CURSORY)      
      LD B,FONT_HEIGHT 
      LD D,0
      LD E,A
      LD HL,0
SCUR_AGN2:
      ADC HL,DE
      DJNZ SCUR_AGN2      ;HL=B*DE
      LD C,FONT_HEIGHT-2  ;2 PIXEL HEIGTH CURSOR       
      LD B,0
      ADC HL,BC           ;ADD FONT_HEIGHT-2 PIXELS
      POP DE              ;RETREIVE 3RD PARAM ON DE
      PUSH HL             ;2ND PARAM Y1
      PUSH DE             ;3RD PARAM X2
      ;INC HL
      INC HL              ; Y2 ADD THE LAST +2 PIXELS  
      PUSH HL             ;4TH PARAM Y2
      CALL LCD_SETXY
      ;SEND THE PIXELS = 2*FONT_WIDTH   
      POP HL              ;GET THE COLOR
      LD B,2*FONT_WIDTH   ;2*8=16
SCUR_AGN3:
      CALL LCD_SETPIXEL   ;DESTROYS D,A
      DJNZ SCUR_AGN3                            
      ;LD A,(CURSORX)
      ;LD (PRECSRX),A      ; SAVE CURSOR TO PREVIOUSX
      ;LD A,(CURSORY)
      ;LD (PRECSRY),A      ; SAVE CURSOR TO PREVIOUSX      
      RET

@LCD_CLRSCR:
     CALL LCD_CLRXY;
     LD HL,(BCOLOR)     
    ; JP METH2
     LD BC,LCD_HEIGHT
CS_AGNA2: PUSH BC
     LD BC,LCD_WIDTH
CS_AGNA1:  CALL LCD_SETPIXEL         ;DESTROYS D,A, HL HAS COLOR INFO
     DEC BC
     LD A,B
     OR C
     JR NZ,CS_AGNA1
     POP BC
     DEC BC
     LD A,B
     OR C     
     JR NZ,CS_AGNA2
     LD HL,0                   ;RESET CURSOR AT 0,0
     LD (CURSORX),HL       
		 RET
    
     
METH2:     
     ;OUTER LOOP HEIGHT TIMESS
     LD B,LCD_HEIGHT.AND.0xFF   ;lsb
     LD C,LCD_HEIGHT.SHR.8+1      ;MSB+1
CS_AGN2:     
     PUSH BC          
     ;INNER LOOP WIDTH TIMES
     LD B,LCD_WIDTH.AND.0xFF   ;lsb
     LD C,LCD_WIDTH.SHR.8+1      ;MSV+1          
CS_AGN1:     
     CALL LCD_SETPIXEL         ;DESTROYS D,A, HL HAS COLOR INFO
     DJNZ CS_AGN1
     DEC C
     JR NZ,CS_AGN1     
     POP BC
     DJNZ CS_AGN2
     DEC C
     JR NZ,CS_AGN2 
     LD HL,0                   ;RESET CURSOR AT 0,0
     LD (CURSORX),HL       
     RET
     
     
;PRINT A MESSAGE AT CURSOR     
@LCD_MSG:
     ;HL HAS THE TEXT BUFFER
     LD A,(HL)
     CP 0
     RET Z
     PUSH HL
     CALL LCD_PRINTCHAR     
     POP HL
     INC HL
     JR LCD_MSG
     
     
