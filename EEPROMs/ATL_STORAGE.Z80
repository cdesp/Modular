	NAME STORAGE_SDCARD



;STORAGE COMMANDS
GLOBAL STRG_INIT
GLOBAL STRG_OPENCRD 
GLOBAL STRG_OPNFILE
GLOBAL STRG_CLSFILE
GLOBAL STRG_DIRLIST
GLOBAL STRG_DIRCHG
GLOBAL STRG_BLKREAD
GLOBAL STRG_BLKWRITE
GLOBAL STRG_TPFILE
GLOBAL STRG_GETPOS
GLOBAL STRG_SETPOS
GLOBAL STRG_GETSIZE
GLOBAL STRG_GETEOF
;THIS SHOULD GO TO RAM
;USES IN RAM
;STRGBUFF  	DEFS 40		;USED FOR DIRECTORY AND FILENAME
;STRGCMD     	DEFS 4
;FID		DB 0


OPENCARD 	EQU 1;
OPENFILE 	EQU 2;
CLOSEFILE 	EQU 3;
READBLOCK 	EQU 6;
WRITEBLOCK 	EQU 7;
POSITIONS 	EQU 8;
POSITIONG 	EQU 9;
LISTDIR 	EQU 10;
CHANGEDIR 	EQU 11;
FILESIZE 	EQU 12;
ENDOFFILE	EQU 13;
INVALIDCMD 	EQU 99;

@FCMDOK 	EQU 200;
@FNOTDIR 	EQU 201;
@FNOTFND 	EQU 202;
@FNOMOR 	EQU 203;


STRG_INIT:	LD A,3			;38400 BPS
		CALL STOR_INI
		RET

;A HAS THE NEW COMMAND
NEWCMD:		LD HL,STRGCMD	
		LD (HL),A
		INC HL
		PUSH HL
		XOR A
		LD B,3
CCAGN:		LD (HL),A
		INC HL
		DJNZ CCAGN
		POP HL			;HL POINTS ON FID IN COMMAND
		RET


SENDCMD:	CALL FLUSHREC
		LD HL,STRGCMD
		LD B,4 
NXTBT:		LD A,(HL)
		CALL STOR_TX
		INC HL
		DJNZ NXTBT
		RET

STRG_OPENCRD:	LD A,OPENCARD
		CALL NEWCMD
		CALL SENDCMD
		CALL DEL2
		CALL STOR_RX   ;GET RESULT	
		RET

;RETURNS EOF 
;A=FID
;RETURNS -1=255 IF EOF=TRUE ELSE FCMDOK=200
STRG_GETEOF:	PUSH AF
		LD A,ENDOFFILE
		CALL NEWCMD
		POP AF
		LD (HL),A	;FID
		CALL SENDCMD
		;CALL DEL2
		CALL STOR_RX	;GET EOF
		RET

;RETURNS FILE SIZE
;A=FID
;RETURNS FILE SIZE ON HL , A =RET STATUS
STRG_GETSIZE:	PUSH AF
		LD A,FILESIZE
		JR GT2BYTES

;RETURNS CURRENT FILE POSITION
;A=FID
;RETURNS FILE POSITION ON HL , A =RET STATUS
STRG_GETPOS:	PUSH AF
		LD A,POSITIONG
GT2BYTES:	CALL NEWCMD
		POP AF
		LD (HL),A	;FID
		CALL SENDCMD
		;CALL DEL2
		CALL STOR_RX	;GET POS/SIZE HIGH BYTE
		LD H,A	
		CALL STOR_RX	;GET POS/SIZE LOW BYTE
		LD L,A	
		CALL STOR_RX   ;GET RESULT	
		RET

;SETS NEW POSITION ON A FILE
;A=FID
;HL NEW POS
;ON RET A=STATUS
STRG_SETPOS:	EX DE,HL
		PUSH AF
		LD A,POSITIONS
		CALL NEWCMD
		POP AF
		LD (HL),A	;FID
		INC HL
		LD (HL),D	;NEW POS ON DE
		INC HL
		LD (HL),E
		CALL SENDCMD
		CALL DEL2
		CALL STOR_RX   ;GET RESULT	
		RET


;PRINTS CURRENT DIRECTORY ON SCREEN
;USES LCD_PRINTCHAR
STRG_DIRLIST:	LD A,LISTDIR
		CALL NEWCMD
		CALL SENDCMD
		CALL DEL2
		;WE RECEIVE THE DIR LIST UNTIL 255
		LD DE,STRGBUFF
NXTCHR		CALL STOR_RX 
		CP 255
		JR Z,DIROUT
		;PRINT TO LCD
		CALL LCD_PRINTCHAR
		JR NXTCHR
DIROUT:		CALL DEL2
		CALL STOR_RX   ;GET RESULT	
		RET

;0 TERMINATED STRING
;ALSO SENDS A ZERO TO THE OTHER SIDE
SENDFNAME:	CALL STOR_TXT ;SEND FILENAME
		XOR A
		CALL STOR_TX
		RET

;CHANGES DIRECTORY TO A DIR NAME ON STRGBUFF
STRG_DIRCHG: 	LD A,CHANGEDIR
		CALL NEWCMD
		CALL SENDCMD
		LD HL,STRGBUFF
        	CALL SENDFNAME		
		CALL DEL2
		CALL STOR_RX   ;GET RESULT	
		RET

;OPENS A FILE WITH ITS NAME ON STRGBUFF
;A=0 FOR READ 1 FOR WRITE 2 FOR READ/WRITE 4 FOR CREATE AND WRITE
STRG_OPNFILE: 	PUSH AF
		LD A,OPENFILE
		CALL NEWCMD
		POP AF
		LD (HL),A	;FID
		CALL SENDCMD 
		LD HL,STRGBUFF
		CALL SENDFNAME
		CALL DEL2	
		CALL STOR_RX   ;GET RESULT	
		;RESULT IS FILE ID (0-10)
		LD (FID),A
		CP 200
		RET ; IF CARRY ERROR OCCURED 

;A HAS THE FID TO BE CLOSED
STRG_CLSFILE:	PUSH AF
		LD A,CLOSEFILE		
		CALL NEWCMD	;HL POINTS ON FID IN COMMAND ON RETURN	
		POP AF
		LD (HL),A	;FID
		CALL SENDCMD
		CALL STOR_RX   	;GET RESULT
		RET

;A THE FID OF THE FILE
;BC NO OF BYTES TO WRITE
;DE THE SOURCE BUFFER
;RET STATUS
STRG_BLKWRITE:	PUSH AF
		LD A,WRITEBLOCK
		CALL NEWCMD	;HL POINTS ON FID IN COMMAND ON RETURN
		POP AF
		LD (HL),A	;FID
		INC HL	
		;BC TOTAL BYTES TO SEND		
		LD A,B		;BYTES HI
		LD (HL),A
		INC HL	
		LD A,C		;BYTES LOW
		LD (HL),A
		CALL SENDCMD  ;SEND BLOCKWRITE COMMAND BC BYTES 		
		EX DE,HL
BWNXCH:		LD A,(HL)
		CALL STOR_TX
		INC HL
		DEC BC
		LD A,B
		OR C
		JR NZ,BWNXCH
		CALL STOR_RX   	;GET RESULT
		RET		


;A THE FID OF THE FILE
;BC THE REQUESTED NO OF BYTES
;DE THE DESTINATION BUFFER
;RET BC  =  BYTES RECEIVED
;USES LCD_MSG TO PRINT ERRORS ON SCREEN
STRG_BLKREAD:	PUSH AF
		LD A,READBLOCK
		CALL NEWCMD	;HL POINTS ON FID IN COMMAND ON RETURN
		POP AF
		LD (HL),A	;FID
		INC HL	
		LD A,B		;BYTES HI
		LD (HL),A
		INC HL	
		LD A,C		;BYTES LOW
		LD (HL),A
		CALL SENDCMD  ;SEND BLOCKREAD COMMAND 0=ALL BYTES
		CALL DEL2
		CALL STOR_RX   ;GET BYTES TO BE SEND HI BYTE
		LD B,A		
		CALL STOR_RX   ;GET BYTES TO BE SEND LOW BYTE
		LD C,A
		LD A,B
		OR C
		JR Z,EREXIT   ;SOME ERROR OCCURED
 		;BC TOTAL BYTES TO RECEIVE
		PUSH BC 		;SAVE BYTES TO RECEIVE		
OFNXCH:		CALL STOR_RX
		LD (DE),A
		INC DE
		DEC BC
		LD A,B
		OR C
		JR NZ,OFNXCH
OFEXIT:		CALL STOR_RX   	;GET RESULT
		POP BC		;TOTAL BYTES RECEIVED		
		RET		
EREXIT:		LD HL,ERRMSG
		CALL LCD_MSG  ;PRINT TO SCREEN
		JR OFEXIT
		
;A THE FID OF THE FILE		
;USES LCD_PRINTCHAR,LCD_MSG TO PRINT ON SCREEN
STRG_TPFILE:	PUSH AF
		LD A,READBLOCK
		CALL NEWCMD	;HL POINTS ON FID IN COMMAND ON RETURN
		POP AF
		LD (HL),A	;FID
		INC HL	
		LD A,B		;BYTES HI
		LD (HL),A
		INC HL	
		LD A,C		;BYTES LOW
		LD (HL),A
		CALL SENDCMD  ;SEND BLOCKREAD COMMAND 0=ALL BYTES
		CALL DEL2
		CALL STOR_RX   ;GET BYTES TO BE SEND HI BYTE
		LD B,A		
		CALL STOR_RX   ;GET BYTES TO BE SEND LOW BYTE
		LD C,A
		LD A,B
		OR C
		JP Z,EREXIT   ;SOME ERROR OCCURED
 		;BC TOTAL BYTES TO RECEIVE
		LD A,13
		PUSH BC
		CALL LCD_PRINTCHAR
		POP BC		
TFOFNXCH:	CALL STOR_RX		;GET THE CHAR
		PUSH BC
		CALL LCD_PRINTCHAR  	;PRINT TO SCREEN
		POP BC
		DEC BC
		LD A,B
		OR C
		JR NZ,TFOFNXCH		
TFOFEXIT:	CALL STOR_RX   ;GET RESULT		
		RET	
TFEREXIT:	LD HL,ERRMSG
		CALL LCD_MSG  ;PRINT TO SCREEN
		JR TFOFEXIT

ERRMSG 		DEFB 13
       		DEFM "ERROR ON RET BYTES"
       		DEFB 13,0
		


;=====SERIAL COMMS WITH RTS/CTS========


;SERIAL COMMS FUNCTIONS
;ALL COMM FUNCTIONS ARE INTERNAL
	;GLOBAL STOR_INI
	;GLOBAL STOR_TX
	;GLOBAL STOR_RX
	;GLOBAL STOR_RXNW
	;GLOBAL STOR_TXT
	;GLOBAL STOR_KEYRD

	;DEVSTOR EQU $30 ; SET ON MAIN

	RBR EQU DEVSTOR+0	;RECEIVER BUFFER REGISTER (READ ONLY) (DLAB = 0)
	THR EQU DEVSTOR+0	;TRANSMITER HOLDING REGISTER (WRITE ONLY) (DLAB = 0)
	IER EQU DEVSTOR+1	;INTERRUPT ENABLE REGISTER (DLAB = 0)
				;BIT 0= ENABLE RECEIVED DATA AVAILABLE INTERRUPT
				;BIT 1= ENABLE TRANSMITTER HOLDING REGISTER EMPTY INTERRUPT
				;BIT 2= ENABLE RECEIVER LINE STATUS INTERRUPT
				;BIT 3= ENABLE MODEM STATUS INTERRUPT
	IIR EQU DEVSTOR+2	;INTERRUPT IDENT. REGISTER (READ ONLY)
				;BIT 0=0 IF INTERRUPT PENDING
				;BIT 1-3 INTERRUPT ID
				;BIT 4,5 =0
				;BIT 6,7 FIFOS ENABLED					
	FCR EQU DEVSTOR+2	;FIFO CONTROL REGISTER (WRITE ONLY)
				;BIT 0 FIFO ENABLE
				;BIT 1 RCVR FIFO RESET
				;BIT 2 XMIT FIFO RESET
				;BIT 3 DMA MODE SELECT
				;BIT 4,5 RESERVED
				;BIT 6 RCVR TRIGGER LSBIT
				;BIT 7 RCVR TRIGGER MSBIT
	LCR EQU DEVSTOR+3	;LINE CONTROL REGISTER
				;BIT 0,1 WORD LENGTH SELECT
				;BIT 2 NUMBER OF STOP BITS
				;BIT 3 PARITY ENABLE
				;BIT 4 EVEN PARITY SELECT
				;BIT 5 STICK PARITY
				;BIT 6 SET BREAK
				;BIT 7 DIVISOR LATCH ACCESS BIT *** DLAB ****
	MCR EQU DEVSTOR+4	;MODEM CONTROL REGISTER 
	LSR EQU DEVSTOR+5	;LINE STATUS REGISTER
				;BIT 0 DATA READY
				;BIT 1 OVERRUN ERROR
				;BIT 2 PARITY ERROR
				;BIT 3 FRAMING ERROR
				;BIT 4 BREAK INTERRUPT
				;BIT 5 TRANSMITTER HOLDING REGISTER
				;BIT 6 TRANSMITTER EMPTY
				;BIT 7 ERROR IN RCVR FIFO
	MSR EQU DEVSTOR+6	;MODEM STATUS REGISTER
	SCR EQU DEVSTOR+7	;SCRATCH REGISTER
	DLL EQU DEVSTOR+0	;DIVISOR LATCH (LEAST SIGNIFICANT BYTE) (DLAB = 1)
	DLM EQU DEVSTOR+1	;DIVISOR LATCH (MOST SIGNIFICANT BYTE) (DLAB = 1)
	
				;A=5 RECEIVE INTERRUPTS ON
;A IS THE BAUD RATE PARAM				
STOR_INI:	PUSH AF
		LD      A,$80          	; Mask to set DLAB on
		OUT     (LCR),A         ; Send to LINe Control Register	
		;LD      A,12           ; Divisor of 12 = 9600 bps with 1.8432 MHz clock
		;LD      A,96           ; Divisor of 96 = 1200 bps with 1.8432 MHz clock
				; 72=1600BPS WITH 1.8432
		;LD A,6			;19200BPS
		;LD A,3			;38400BPS
		;LD A,2			;56000BPS
		;LD A,1			;115200BPS				
  		POP AF
		OUT     (DLL),A        	; Set LSB of divisor
		LD      A,00            ; This will be the MSB of the divisior
		OUT     (DLM),A        	; Send to the MSB register
		LD      A,$03          	; 8 bits, 1 stop, no parity (and clear DLAB)
		OUT     (LCR),A        	; Write new value to LCR
		;LD A, 1+2+4+8							; set fifo mode and reset fifio counters		//was 0 and commented 
  		LD A, 0							
  		OUT 	(FCR),A						;//was commented
		LD      A,$00          	; 5 A=0 Disable all INterrupts
		OUT     (IER),A        	; Send to INterrupt Enable Register	
	    XOR A					;NOT ready to receive SIGNAL RTS 0
        OUT (MCR),A  		
		RET
		


; RETurns when UART is ready to receive

STORTXRD: 	PUSH    AF
STORTXLP: 	IN      A,(LSR)        	; fetch the control register
        	BIT     5,A             ; bit will be set if UART is ready
        	JR      Z,STORTXLP
        	POP     AF
        	RET		

;TODO:IMPLEMENT A TIMEOUT
WAITCTSLOW:	PUSH AF
TSTAGN:		IN A,(MSR)
			BIT 4,A 				;COMPLEMENT OF CTS SO IF CTS=0 THIS IS 1
			JR NZ,WCLEX
			JR TSTAGN
WCLEX:		POP AF
			RET
			
RS_TX EQU $05FE

; Sends byte IN A to the UART
STOR_TX:	;test CTS if low then send
			CALL WAITCTSLOW
			;push af
			;ld a, 'C'
			;call RS_TX
			;pop af
			CALL    STORTXRD
			;push af
			;ld a, 'R'
			;call RS_TX
			;pop af
        	OUT     (THR),A
        	RET

;Sends a zero terminated string
STOR_TXT: 	LD A,(HL)
		INC HL	
		CP 0
		RET Z
        	CALL STOR_TX
		JR STOR_TXT
	



; Wait for a byte from the UART, and save it IN A

STOR_RX:  	DI
        	LD A,2 ;BIT 1					;ready to receive SIGNAL RTS 1 MEANS ARDUINO CTS=0
        	OUT (MCR),A
			CALL    STORRXRD              
STOR_GTCH: 	XOR A						;NOT ready to receive SIGNAL RTS 0
        	OUT (MCR),A        
	      	IN A,(RBR)
	      	EI
        	RET

STOR_RXNW:	LD A,2					;ready to receive SIGNAL RTS 1
        	OUT (MCR),A
			IN      A,(LSR)        	; fetch the conrtol register
        	BIT     0,A                    
        	JR Z,STOR_NOCHAR
        	DI
        	JR STOR_GTCH        
STOR_NOCHAR: 	XOR A  ;RETURN ZERO
        	RET
        
FLUSHREC:	LD B,10
FRAGN:      CALL  STOR_RXNW
			DJNZ FRAGN       
			XOR A
			OUT (MCR),A
			RET


; RETurns when UART has received data


STORRXRD: 	DI
        	PUSH    AF
STORRXLP: 	IN      A,(LSR)        	; fetch the conrtol register
        	BIT     0,A             ; bit will be set if UART has data
        	JR      Z,STORRXLP
        	POP     AF
        	EI
        	RET		
	
; ZF=1 IF NO CHAR SENT
; ZF=0 IF CHAR WAITING T BE RECEIVED
STOR_KEYRD:	IN      A,(LSR)        	; fetch the conrtol register
         	BIT     0,A             ; bit will be set if UART has data        
         	RET	





	END
