;struct Sprites
;nosprites byte 1
;blendaddr: word ;maxwid maxhei 64x64x2 bytes
		
		
;struct sprite
;PosX word    2  0 position X in Screen
;PosY word    2  2 position Y in Screen
;NewX word    2  4 new position X in Screen
;NewY word    2  6 new position Y in Screen
;wid:byte     1  8 width of sprite
;hei:byte     1  9 height of sprite
;curpic:byte  1  10 current picture no
;npics:byte   1  11 number of sprite pics
;graddr:word  2  12 address in memory graphics are stored
;scraddr:word 2  14 address in memory screen background is stored
;
;
;total bytes needed in struct 16
;bytes needed for graphics (wid*hei)*npics*2
;
;routines
;getScreenBG sprno  puts data from screen to memory
;setScreenBG sprno  puts data from memory to screenBG
;setScreenSPR sprno,memaddr  puts data from blend memory to screen
;blendSprite sprno
;createSprite returns sprno IN A
;getSpriteStruct sprno returns addr of start of struct

		
		

		MAXSPR EQU 20
		MAXSPRW EQU 30
		MAXSPRH EQU 30
		SPRSTRCSIZE EQU 16

;TEMP VARS FOR WRITING OR READING THE SCREEN
@TEMW		DB 0	;SPRITE WIDTH
@TEMH		DB 0	;SPRITE HEIGHT
@TMLNY		DW 0	;SPRITE LINE Y ADDRESS ADD 160 TO NEXT
@TMLNX		DW 0	;SPRITE LINE X OF		
		
;creates a new sprite
;RETUNRS SPR NO ON A
@createSprite:	LD A, (NOSPRITES)
		CP MAXSPR
		JR NC, CSERROR
		INC A
		LD (NOSPRITES), A
		DEC A
		RET
CSERROR:	LD A, 255
		RET
		
@getSpriteStruct: LD HL, 0
		LD DE, SPRSTRCSIZE
		LD B, A
		CP 0
		JR Z, GSSEXIT
GSSAGN:		ADD HL, DE
		DJNZ GSSAGN
GSSEXIT:	EX DE, HL
		LD HL, SPRT
		ADD HL, DE
		PUSH HL
		POP IX
		RET
			
;COPIES THE SCREEN BACKGROUND BEFORE WE COPY THE BLENDED GRAPH	
;A THE SPRITE NO	
@getScreenBG:	CALL getSpriteStruct 	
		LD D,(IX+2)							;GET Y
		LD E,(IX+3)
		;CALC START ADDRESS
		;y*160+X  
		LD A,160
		CALL Mult12	;HL=A*DE=160*Y
		LD D,(IX)							;GET X
		LD E,(IX+1)
		ADD HL,DE	;ADD X
		LD DE,$6000	;START OF VIDEO BUFFER
		ADD HL,DE	;HL THE SPRITE VIDEO START ADDRESS 		
		LD (TMLNY),HL	;SAVE START LINE ADDRESS ON VID BUF
		LD B, (IX + 14) 						;SCRADDRESS
		LD C, (IX + 15)
		LD A,(IX+9)	;SPRITE HEIGHT ON TEMH
		DEC A
		LD (TEMH),A
		EX DE,HL	;DE THE SPRITE VIDEO START ADDRESS 		
GSBGDOROW:	LD A,(IX+8)   	;SPRITE WIDTH ON TEMH
		OR A
		RRA		;HALVE THE PIXEL WIDTH CAUSE 2 PIXELS / BYTE
		DEC A
		LD (TEMW),A
GSBGNXPXL:	LD A,(DE)	;DE THE VIDEO BUF ADDR TO READ 2 PIXELS 
		RRA
		RRA
		RRA
		RRA
		AND $0F
		LD (BC),A	;LEFT PIXEL
		INC BC
		LD A,(DE)
		AND $0F
		LD (BC),A	;RIGHT PIXEL
		INC BC
		;NEXT BYTE
		LD HL,TEMW
		LD A,(HL)
		CP 0		;CAUSE WE START ON WIDTH-1
		JR Z, GSBGNXROW		
		DEC (HL)	;MINUS A BYTE=2 PIXELS
		INC DE		;NEXT 2 PIXELS ON SCREEN
		JR GSBGNXPXL
GSBGNXROW:	LD HL,TEMH
		LD A,(HL)
		DEC (HL)
		CP 0		;CAUSE WE START ON HEIGHT-1
		JR Z,GSBGDOEXIT		
		;SET NEXT LINE START ADDR
		LD HL,(TMLNY)
		LD DE,160
		ADD HL,DE
		LD (TMLNY),HL
		EX DE,HL	;DE THE VIDEO BUF ADDR TO READ 2 PIXELS 
		JR GSBGDOROW
GSBGDOEXIT:	RET
		
;SETS THE SCREEN BACKGROUND BACK TO SCREEN TO ERASE THE SPRITE
;A THE SPRITE NO		
@SetScreenBG: 	CALL getSpriteStruct 	
		LD B, (IX + 14) 						;SCRADDRESS
		LD C, (IX + 15)
		JR SetToScreen

;PUTS THE BLENDED GRAPH TO SCREEN
;A THE SPRITE NO
@setScreenSPR:  CALL getSpriteStruct 
		LD BC, (BLENDADDR) 						;BLEND ADDRESS
		
;COPIES A SPRITE TO SCREEN 
;BC THE ADDRESS OF THE SPRITE
@SetToScreen:	LD D,(IX+2)							;GET Y
		LD E,(IX+3)
		;CALC START ADDRESS
		;y*160+X  
		LD A,160	
		PUSH BC	
		CALL Mult12	;A*DE=160*Y
		POP BC
		LD D,(IX)							;GET X
		LD E,(IX+1)
		ADD HL,DE	;ADD X
		LD DE,$6000	;START OF VIDEO BUFFER
		ADD HL,DE	;HL THE SPRITE VIDEO START ADDRESS 		
		LD (TMLNY),HL
		LD A,(IX+9)	;SPRITE HEIGHT ON TEMH
		DEC A
		LD (TEMH),A
		EX DE,HL	;DE THE SPRITE VIDEO START ADDRESS 		
SSBGDOROW:	LD A,(IX+8)   	;SPRITE WIDTH ON TEMH
		OR A
		RRA		;HALVE THE PIXEL WIDTH CAUSE 2 PIXELS / BYTE
		DEC A
		LD (TEMW),A
SSBGNXPXL:	LD A,(BC)	;BC THE LEFT BACKG PIXEL 		
		RLA
		RLA
		RLA
		RLA
		LD L,A
		INC BC
		LD A,(BC)	;BC THE RIGHT BACKG PIXEL 
		OR L
		INC BC		;NEXT PIXEL
		LD (DE),A	;SET 2 PIXELS ON SCREEN
		;NEXT PIXEL
		LD HL,TEMW
		LD A,(HL)
		CP 0		;CAUSE WE START ON WIDTH-1
		JR Z, SSBGNXROW		
		DEC (HL)	;MINUS A HORIZONTAL BYTE=2 PIXELS
		INC DE		;NEXT 2 PIXELS ON SCREEN
		JR SSBGNXPXL
SSBGNXROW:	LD HL,TEMH
		LD A,(HL)
		DEC (HL)
		CP 0		;CAUSE WE START ON HEIGHT-1
		JR Z,SSBGDOEXIT		
		;SET NEXT LINE START ADDR
		LD HL,(TMLNY)
		LD DE,160
		ADD HL,DE
		LD (TMLNY),HL
		EX DE,HL	;DE THE VIDEO BUF ADDR TO READ 2 PIXELS 
		JR SSBGDOROW
SSBGDOEXIT:	RET
		

;BLEND THE SPRITE GRAPHICS WITH THE BACKGROUND 	
;A THE SPRITE NO	
@blendSprite:	PUSH IY		;SAVE IY
		CALL getSpriteStruct
		;COPY FROM graddr TO BLENDADDR
		LD H,(IX+8)	;SPR WIDTH
		LD E,(IX+9)	;SPR HEIGHT
		CALL MULT8	;SPR SIZE WIDTH*HEIGHT
		;HL THE SIZE IN BYTES
		LD B,H
		LD C,L
		LD H, (IX + 12) 						;GRADDR TODO GRADDR*curpic
		LD L, (IX + 13)
		LD D, (IX + 14)							;SCRADDR COPY
		LD E, (IX + 15)
		PUSH DE
		POP IY								;SCRADDR
		LD DE, (BLENDADDR)
BSAGN:		LD A, (HL) 							;GET COLOR FROM GRAPH ITS 2PIXELS PER BYTE
		RRA
		RRA
		RRA
		RRA
		AND $0F		;GET LEFT PIXEL	
		CALL BSLFRG    	
		LD A, (HL)
		AND $0F		;GET RIGHT PIXEL	
		CALL BSLFRG    
		INC HL		;NEXT  BYTE FOR SPRITE 2 PIXELS
		LD A, B
		OR C
		JR NZ,BSAGN	;CHECK FOR END
		POP IY		;RESTORE IY ON EXIT
		RET 
		;PAINTS THE PIXEL
BSLFRG:		;A HAS THE COLOR		
		CP 0		;0 IF BACKGROUND ON SPRITE
		JR NZ, BSNOBLEND
		LD A, (IY) 	;COLOR FROM BACKGROUND
									;GET SCREEN COLOR WHEN BLACK ON SPRITE
BSNOBLEND:	EX DE, HL
		LD (HL), A
		INC HL		;NEXT BLEND PIXEL THIS INC DE
		EX DE, HL
		INC IY		;NEXT SCREEN COPY PIXEL
		DEC BC		;MINUS 1 PIXEL
		RET
	
;PLOTPIXEL AT 320X200
;HL=X , DE=Y  A=COLOR
@VGA_PLOTPIXEL:	PUSH HL								;CHECK BOUNDS
		PUSH AF
		LD A,E
		LD DE,$6000
;HALVE HL=X CAUSE 2 PIXELS ONE BYTE
		SRL H
		RR L
		ADD HL, DE 							;FIND COLUMN
		PUSH HL
		LD DE, 160
		;HL=A*160	=Y*160		
		CALL Mult12
		POP DE
		ADD HL,DE
PP_DOPLOTPX:	POP BC 								;B HAS THE COLOR
		POP DE 								;DE=X CHECK IF IT IS EVEN OR ODD AND CHANGE THE PIXEL
		LD A, (HL) 							;GET PIXEL BYTE
		BIT 0, E 							;CHECK X IS EVEN OR ODD
		JR Z, PP_DOEVEN 							;EVEN
;SET RIGHT 4 BITS
		AND $F0 							;CLEAR RIGHT 4 BITS
		JR PP_DPEXIT
;SET LEFT 4BITS
PP_DOEVEN:	RLC B
		RLC B
		RLC B
		RLC B
		AND $0F 							;ZERO LEFT
PP_DPEXIT:	OR B 								;MIX PIXELS
		LD (HL), A
		RET			
		
		
		
		SPRITES EQU $
		NOSPRITES DB 0
		BLENDADDR DEFW BLENDAREA
		
		
		SPRT EQU $ 							;STRUCT SPRITE ARRAY
		DS MAXSPR * SPRSTRCSIZE
		
		BLENDAREA DS MAXSPRW * MAXSPRH  				;1 BYTE PER PIXEL
