;ORG
		
;COLOR
		@COL_BLACK EQU 0x0000
		@COL_RED EQU 0xF800
		@COL_GREEN EQU 0x07C0
		@COL_YELLOW EQU 0xFFC0
		@COL_BLUE EQU 0x003F
		@COL_MAGENTA EQU 0xF83F 					;0xF863
		@COL_CYAN EQU 0x07FF
		@COL_WHITE EQU 0xFFFF
		
		
		
;LOCAL CONSTS
		LCD_RS EQU DEVTFT 						;PORT TO CONTROL RS PIN 16=cs+rs+low = COMMAND  A0 CONNECT TO RS
		LCD_CS EQU DEVTFT + 1 						;PORT TO CONTROL CS PIN 17=cs+rs_high  = DATA
		@LCD_WIDTH EQU 799
		@LCD_HEIGHT EQU 479
		FONT_WIDTH EQU 8
		FONT_HEIGHT EQU 10
		TOTLINES EQU (LCD_HEIGHT + 1) / FONT_HEIGHT			;TOTAL CHAR LINES
		
		
		
		
		
		
LCD_WR_DAT16:									;TWO PARAMS
;D=VL E=VH
		LD A, E
		OUT (LCD_CS), A
		
LCD_RD_DAT:	
LCD_RD_BUS:	
;DESTROYS A
		IN A, (LCD_CS)
		RET
		
		
LCD_WR_DAT:	
LCD_WR_BUS:									;ONE PARAM VL
;PASS BY REGISTER D=VL
;DESTROYS A
		LD A, D
		OUT (LCD_CS), A
		RET
		
		
LCD_WR_COM:									;ONE PARAM VL
;PASS BY REGISTER D=VL
;DESTROYS A
		LD A, D
		OUT (LCD_RS), A
		RET
		
		
LCD_WR_COM2:									;ONE PARAM VL
;PASS BY REGISTER D=VL
;DESTROYS A
		
		XOR A
		OUT (LCD_RS), A 						;RS LOW = COMMAND BYTE
		CALL LCD_WR_BUS
		LD A, 1
		OUT (LCD_RS), A 						;RS HIGH  = DATA BYTE
		RET
		
@LCD_INIT:									;INITIALIZE THE SSD1963
		
		LD D, 0xE2 							;PLL multiplier, set PLL clock to 120M
		CALL LCD_WR_COM 						;N=0x36 for 6.5M, 0x23 for 10M crystal
		LD D, 0x23 							;1E
		CALL LCD_WR_DAT
		LD D, 0x02
		CALL LCD_WR_DAT
		LD D, 0x54
		CALL LCD_WR_DAT
		LD D, 0xE0 							; PLL enable
		CALL LCD_WR_COM
		LD D, 0x01
		CALL LCD_WR_DAT
		LD B, 10 							;delay(10);
		CALL DELAYMICRO
		LD D, 0xE0 							; PLL enable
		CALL LCD_WR_COM
		LD D, 0x03
		CALL LCD_WR_DAT
		LD B, 10 							;delay(10);
		CALL DELAYMICRO
		
		LD D, 0x01 							; software reset
		CALL LCD_WR_COM
		LD B, 20 							;delay(20); MICROSECS
		CALL DELAYMICRO
		LD D, 0xE6 							;PLL setting for PCLK, depends on resolution
		CALL LCD_WR_COM
		LD D, 0x03
		CALL LCD_WR_DAT
		LD D, 0x33 							;FF
		CALL LCD_WR_DAT
		LD D, 0x33 							;FF
		CALL LCD_WR_DAT
		
		LD D, 0xB0 							;LCD SPECIFICATION
		CALL LCD_WR_COM
		LD D, 0x20
		CALL LCD_WR_DAT
		LD D, 0x00
		CALL LCD_WR_DAT
		LD D, 0x03 							;Set HDP  799
		CALL LCD_WR_DAT
		LD D, 0x1F
		CALL LCD_WR_DAT
		LD D, 0x01 							;Set VDP  479
		CALL LCD_WR_DAT
		LD D, 0xDF
		CALL LCD_WR_DAT
		LD D, 0x00
		CALL LCD_WR_DAT
		
		
		LD D, 0xB4 							;HSYNC
		CALL LCD_WR_COM
		LD D, 0x04 							;03         ;Set HT 928
		CALL LCD_WR_DAT
		LD D, 0x1F 							;A0
		CALL LCD_WR_DAT
		LD D, 0x00 							;Set HPS  46
		CALL LCD_WR_DAT
		LD D, 0xD2 							;2E
		CALL LCD_WR_DAT
		LD D, 0x00 							;30         ;Set HPW  48
		CALL LCD_WR_DAT
		LD D, 0x00 							;Set LPS  15
		CALL LCD_WR_DAT
		LD D, 0x00 							;0F
		CALL LCD_WR_DAT
		LD D, 0x00
		CALL LCD_WR_DAT
		
		LD D, 0xB6 							;VSYNC
		CALL LCD_WR_COM
		LD D, 0x02 							;Set VT 525
		CALL LCD_WR_DAT
		LD D, 0x0C 							;0D
		CALL LCD_WR_DAT
		LD D, 0x00 							;Set VPS  16
		CALL LCD_WR_DAT
		LD D, 0x22 							;10
		CALL LCD_WR_DAT
		LD D, 0x00 							;10         ;Set VPW  16
		CALL LCD_WR_DAT
		LD D, 0x00 							;Set FPS  8
		CALL LCD_WR_DAT
		LD D, 0x00 							; 08
		CALL LCD_WR_DAT
		
		LD D, 0xB8
		CALL LCD_WR_COM
		LD D, 0x0F 							;07         ;GPIO3=input, GPIO[2:0]=output
		CALL LCD_WR_DAT
		LD D, 0x01 							;GPIO0 normal
		CALL LCD_WR_DAT
		
		LD D, 0xBA
		CALL LCD_WR_COM
		LD D, 0x01 							;0F
		CALL LCD_WR_DAT 						;GPIO[3:0] out 1
		
		LD D, 0x36 							;rotation
		CALL LCD_WR_COM
		LD D, 0x08 							;2A
		CALL LCD_WR_DAT
		
		LD D, 0xF0 							;pixel data interface
		CALL LCD_WR_COM
		LD D, 0x06 							;CHANGE THIS FOR 8 BIT INTERFACE  6=9BIT SEND 2 BYTES
		CALL LCD_WR_DAT
		
		LD B, 5 							;delay(5);
		CALL DELAYMICRO
		
		LD D, 0xBC 							;SET THE IMAGE POST PROCESSOR
		CALL LCD_WR_COM
		LD D, 0x40
		CALL LCD_WR_DAT
		LD D, 0x80
		CALL LCD_WR_DAT
		LD D, 0x40
		CALL LCD_WR_DAT
		LD D, 0x01
		CALL LCD_WR_DAT
		LD B, 5 							;delay(5);
		CALL DELAYMICRO
		
		LD D, 0x35 							;tear on  0X34 TEAR OFF
		CALL LCD_WR_COM
		LD D, 0x00 							;ONLY V-BLNK=0 , V + H =1
		CALL LCD_WR_DAT
		
		LD D, 0x29 							;display on
		CALL LCD_WR_COM
		LD D, 0xBE 							;set PWM for B/L
		CALL LCD_WR_COM
		LD D, 0x06
		CALL LCD_WR_DAT
		LD D, 0xF0
		CALL LCD_WR_DAT
		LD D, 0x01
		CALL LCD_WR_DAT
		LD D, 0xF0
		CALL LCD_WR_DAT
		LD D, 0x00
		CALL LCD_WR_DAT
		LD D, 0x00
		CALL LCD_WR_DAT
		
		LD D, 0xD0
		CALL LCD_WR_COM
		LD D, 0x0D
		CALL LCD_WR_DAT
		
;SET VIEWPORT
		LD HL, 0
		PUSH HL
		PUSH HL
		LD HL, 799
		PUSH HL
		LD HL, 479
		PUSH HL
		CALL LCD_SETXY
		RET
		
		
@LCD_SETXY:									;SET WINDOW ON LCD TO FILL WITH BYTES
;4 PARAMS PASS BY STACK X1,Y1,X2,Y2
;2 BYTES EACH PARAM TOTAL 8 BYTES
;X1,X2,Y1,Y2   X1,X2 SHOULD SWAP Y1,Y2 CAUSE OF THE LCD ORIENTATION
;WE SEND HERE
;X1 = IX+6_7  Y1=IX+4_5
;X2=  IX+2_3  Y2=IX+0_1
		
;WE SEND ON LCD
;Y1=IX+6_7 Y2=IX+2_3
;X1=IX+4_5 X2=IX+0_1
;HIGH BYTE FIRST SO +8 IS H AND +7 IS L
;SHOULD ADD SP,8 AFTER RET
		
		LD IX, 2
		ADD IX, SP
		LD D, 0x2A 							;SEND IX PARAMS
		CALL LCD_WR_COM
		LD D, (IX + 7)
		CALL LCD_WR_DAT
		LD D, (IX + 6)
		CALL LCD_WR_DAT
		LD D, (IX + 3)
		CALL LCD_WR_DAT
		LD D, (IX + 2)
		CALL LCD_WR_DAT
		LD D, 0x2B 							;SEND Y PARAMS
		CALL LCD_WR_COM
		LD D, (IX + 5)
		CALL LCD_WR_DAT
		LD D, (IX + 4)
		CALL LCD_WR_DAT
		LD D, (IX + 1)
		CALL LCD_WR_DAT
		LD D, (IX)
		CALL LCD_WR_DAT
		LD D, 0x2C 							;SEND DATA
		CALL LCD_WR_COM
		POP DE
		LD HL, 4 * 2 							;REMOVE 4 PARAMS FROM STACK
		ADD HL, SP
		LD SP, HL
		EX DE, HL
		JP (HL)
		
		
@LCD_SETPIXEL:									;SEND A 16 BIT VALUE FOR COLOR
;COLOR VALUE ON HL  VH & VL
;DESTROYS D,A
		LD D, H
		CALL LCD_WR_DAT
		LD D, L
		CALL LCD_WR_DAT
		RET
		
@LCD_GETPIXEL:									;GET A 16 BIT VALUE FOR COLOR
;COLOR VALUE ON HL  VH & VL
;DESTROYS D,A
		LD D, 0x2E 							;READ DATA
		CALL LCD_WR_COM
@LCD_GTPXL:	CALL LCD_RD_DAT
		LD H, A
		CALL LCD_RD_DAT
		LD L, A
		RET
		
;READS A PIXEL FROM VIDEO BUFFER
;PARAMS ON STACK X,Y 2 BYTES EACH
;SELF CLEANING THE STACK FROM PARAMS
;RESULT ON HL
@LCD_READPIXEL:	PUSH IX 							; 2 PARAMS ON STACK TOTAL 4 BYTES
		LD IX, 4 							;2 FOR RET ADDR AND 2 FOR PUSH IX
		ADD IX, SP
		LD H, (IX + 3) 							;X
		LD L, (IX + 2) 							;X
		LD D, (IX + 1) 							;Y
		LD E, (IX) 							;Y
		PUSH HL
		PUSH DE
		PUSH HL
		PUSH DE
		CALL LCD_SETXY
		CALL LCD_GETPIXEL
		PUSH HL
		CALL LCD_CLRXY
		POP DE 								;RESULT COLOR
		POP IX
		POP BC 								;RET ADDR
		LD HL, 2 * 2 							;REMOVE PARAMS FROM STACK
		ADD HL, SP
		LD SP, HL
		EX DE, HL 							;HL RESULT
		PUSH BC 							;RET ADDR ON STACK
		RET
		
		
@LCD_DRAWPIXEL:									; 2 PARAMS ON STACK TOTAL 4 BYTES
		LD IX, 2 							;setXY(x, y, x, y);
		ADD IX, SP
		LD H, (IX + 3) 							;X
		LD L, (IX + 2) 							;X
		LD D, (IX + 1) 							;Y
		LD E, (IX) 							;Y
		PUSH HL
		PUSH DE
		PUSH HL
		PUSH DE
		CALL LCD_SETXY
		LD HL, (FCOLOR)
		CALL LCD_SETPIXEL
		CALL LCD_CLRXY
		RET
		
@LCD_CLRXY:									;RESET LCD WINDOW TO FULL
		LD HL, 0
		PUSH HL
		PUSH HL
		LD HL, LCD_WIDTH
		PUSH HL
		LD HL, LCD_HEIGHT
		PUSH HL
		CALL LCD_SETXY
		RET
		
		
;FILL AN AREA AROUND POINT X,Y
;BOTH PARAMS ON STACK
;COLOR TO FILL FCOLOR
;AREA BOUNDS BY BCOLOR
@LCD_FILL:	
		EXX
		POP DE 								;save return addr to de'
		EXX
		CALL _FILL
		EXX
		PUSH DE 							;restore return addr from de'
		EXX
		RET
		
@LCD_PRCH:	
;A THE CHAR TO BE PRINTED ON CURSORX AND CURSORY
;SETXY(CURSORX*FONT_WIDTH,CURSORY*FONT_HEIGHT,(CURSORX+1)*FONT_WIDTH,(CURSORY+1)*FONT_HEIGHT)
;FONT_PATTERN = B=FONT_ADDR  C=A FOR EACH FONT LINE JUST INCREASE B
		PUSH AF
		POP DE 								;FLAGS ON E
		CP 0X08 							;BACKSPACE
		JR Z, PRCHOS_DOBCKSPC
		CP 0X0A 							;LINE FEED JUST IGNORE IT
		RET Z
		CP 0X0D 							;CHECK FOR ENTER
		JR NZ, PRCH_DOPRN
		LD HL, CURSORX
		JP PRCH_NEWLN
PRCHOS_DOBCKSPC:	
		LD HL, CURSORX
		LD A, (HL)				
		CP 1 								;COMPARE WITH COLUMN 1 CAUSE OF THE PROMPT ON COLUMN 0
		RET Z
		DEC (HL)
		PUSH DE
		POP AF								;GET CARRY FLAG BACK
		RET NC								;IF C THEN DELETE LEFT CHAR ALSO
		PUSH HL
		LD A, 32 							;PRINT SPACE
		CALL PRCH_DOPRN 
		POP HL
		DEC (HL)
		RET


;THIS PRINT A CHAR ON LCD BUT IT WORKS FRO THE BBC BASIC
;TODO: MAKE IT GO AWAY
@LCD_PRINTCHAR:	
;A THE CHAR TO BE PRINTED ON CURSORX AND CURSORY
;SETXY(CURSORX*FONT_WIDTH,CURSORY*FONT_HEIGHT,(CURSORX+1)*FONT_WIDTH,(CURSORY+1)*FONT_HEIGHT)
;FONT_PATTERN = B=FONT_ADDR  C=A FOR EACH FONT LINE JUST INCREASE B
		CP 0X08 							;BACKSPACE
		JR Z, PRCH_DOBCKSPC
		CP 0X0A 							;LINE FEED JUST IGNORE IT
		RET Z
		CP 0X0D 							;CHECK FOR ENTER
		JR NZ, PRCH_DOPRN
		LD HL, CURSORX
		JP PRCH_NEWLN
PRCH_DOBCKSPC:	
		LD HL, CURSORX
		LD A, (HL)		
		JR C, DOREALBCKSPC
;IF C IS NOT SET THEN GO LEFT
		CP 1 								;COMPARE WITH COLUMN 1 CAUSE OF THE PROMPT ON COLUMN 0
		RET Z
		DEC (HL)
		RET
DOREALBCKSPC:	
		CP 1 								;COMPARE WITH COLUMN 1 CAUSE OF THE PROMPT ON COLUMN 0
		JR Z, PRCH_DOBCKSPC2 						;IF 0 WE ARE ON THE 1ST COLUMN SO NOTHING TO DO JUST DELETE THE 8=BS FROM BUFFER
		DEC (HL) 							;GO 1 POSITION BACK
		PUSH HL
		LD A, 32 							;PRINT SPACE
		CALL PRCH_DOPRN 						;THIS FORWARDS THE CURSOR SO WE SHOULD GO BACK AGAIN
		POP HL
		DEC (HL) 							;GO 1 POSITION BACK
		OR A
;NOW DELETE FROM THE BASIC BUFFER TOO
;BS =8 ALREADY PUT ON BUFFER SO WE SHOULD GO BACK 2 PLACES
PRCH_DOBCKSPC2:	
		LD IX, 2
		ADD IX, SP
		LD H, (IX + 1) 							;POSITION IN ACCS FOR THE NEW CHARACTER
		LD L, (IX) 							;POSITION IN ACCS FOR THE NEW CHARACTER
		LD A, 0 							;NOT XOR WE DONT WANT TO MESS WITH ZERO FLAG
		JR Z, PRCH_SKIP1 						;WE ARE ON COLUMN 1
		DEC HL 								;PREVIOUS POSITION DELETE BACKSPACE
		LD (HL), A 							;PUT 0 ON LAST POSITION
PRCH_SKIP1:	
		DEC HL 								;PREVIOUS POSITION DELETE PREVIOUS CHAR
		LD (HL), A 							;PUT 0 ON LAST POSITION
		LD (IX + 1), H 							;PUT POSITION BACK ON STACK IT WILL POPED
		LD (IX), L
		RET
		
PRCH_DOPRN:	
		PUSH AF 							;SAVE CHAR TO STACK
		LD (LASTCHAR), A 						;SAVE LAST PRINTED CHAR
;TODO:CHECK IF VDU 4 TEXT OR 5 GRAPH
;SET WINDOW TO PRINT CHAR ON GRAPH
; JP PRCHDO TO PRINT IT
		LD A, (VDUMODE)
		CP 5
		JR NZ, VDU4
		LD HL, (GR_LASTX)
		PUSH HL
		LD DE, (GR_LASTY)
		PUSH DE
		LD BC, FONT_WIDTH - 1
		ADD HL, BC
		PUSH HL
		LD BC, FONT_HEIGHT - 1
		EX DE, HL
		ADD HL, BC
		PUSH HL
		CALL LCD_SETXY
		JR PRCHDO
VDU4:		LD A, (CURSORX)
		LD B, FONT_WIDTH
		LD D, 0
		LD E, A
		LD HL, 0
		OR A 								; CLEAR CARRY
PRCH_AGN1:	
		ADC HL, DE
		DJNZ PRCH_AGN1 							;HL=DE*B
		PUSH HL 							;1ST PARAM X1
		LD DE, FONT_WIDTH
		ADC HL, DE
		DEC HL
		PUSH HL 							;SAVE 3RD PARAM X2
;LD A,(CURSORY)
		CALL LCD_CALCLINE 						;SCROLL CALC
		LD B, FONT_HEIGHT
		LD D, 0
		LD E, A
		LD HL, 0
PRCH_AGN2:	
		ADC HL, DE
		DJNZ PRCH_AGN2
		POP DE 								;RETREIVE 3RD PARAM X2
		PUSH HL 							;2ND PARAM Y1
		PUSH DE 							;3RD PARAM X2
		LD DE, FONT_HEIGHT
		ADC HL, DE 							;CALC 4TH PARAM
		DEC HL 								;4TH PARAM -1
		PUSH HL 							;4TH PARAM Y2
		CALL LCD_SETXY
PRCHDO:		POP AF 								;CHAR TO PRINT FROM STACK
		OR A
		LD HL, FONT_ADDR
		LD D, 0
		LD E, A
		ADC HL, DE 							;THIS IS THE CHAR ADDRESS
		PUSH HL
		POP DE 								; CHAR ADDRESS ON DE
		LD C, FONT_HEIGHT 						; TOTAL FONT LINES
PRCH_AGN3:	
		LD A, (DE) 							;FONT 8BIT PATTERN FOR A LINE
		LD B, FONT_WIDTH
PRCH_AGN4:	
		SLA A 								;CHECK BIT FOR 1=FCOLOR OR 0=BCOLOR
		JR C, FORECOLOR
		LD HL, (BCOLOR)
		JR PRCH_CONT
FORECOLOR:	
		LD HL, (FCOLOR)
PRCH_CONT:	
		PUSH AF
		PUSH DE 							;TODO:PROBABLY NOT NEEDED HERE
		CALL LCD_SETPIXEL
		POP DE
		POP AF
		DJNZ PRCH_AGN4
		INC D 								;ADD 256 FOR NEXT CHAR PATTERN
		DEC C
		JR NZ, PRCH_AGN3
;FORWARD CURSOR
		LD HL, CURSORX
		LD A, (HL)
		INC A
		CP 80
		JP Z, PRCH_NEWLN 						;NEW LINE
		LD (HL), A
		RET
		
;CALULATE LINE NO AFTER SCROLL
@LCD_CALCLINE:	LD A, (SCRLN)
		LD D, A
		LD A, (CURSORY) 						;480/10 MAKES 48 LINES
		ADD A, D
		CP TOTLINES
		RET C
;WE ARE OVER 48 LINES
		SUB TOTLINES
		RET
		
		
		
;SETS HORIZONTAL SCROLL (LANDSCAPE MODE) 480 LINES TO SCROLL
LCD_SETSCROLL:	LD D, 0x33
		CALL LCD_WR_COM
		LD D, 0X00 							;TOP FIXED NO OF LINES 2 BYTES HIGH (0)
		CALL LCD_WR_DAT
		LD D, 0X00 							;TOP FIXED NO OF LINES 2 BYTES LOW
		CALL LCD_WR_DAT
		LD D, 0X01 							;SCROLL LINES NO OF LINES 2 BYTES HIGH (480)
		CALL LCD_WR_DAT
		LD D, 0XE0 							;SCROLL LINES NO OF LINES 2 BYTES LOW
		CALL LCD_WR_DAT
		LD D, 0X00 							;BOTTOM FIXED NO OF LINES 2 BYTES HIGH (0)
		CALL LCD_WR_DAT
		LD D, 0X00 							;BOTTOM FIXED NO OF LINES 2 BYTES LOW
		CALL LCD_WR_DAT
		XOR A
		LD (SCRLN), A
		RET
		
;SCROLLS SCRLN*10 LINES
@LCD_DOSCROLL:	LD A, (SCRLN)
		INC A
		CP TOTLINES
		JR C, DS_NXT
		SUB TOTLINES
DS_NXT:		LD (SCRLN), A
		LD L, A
		LD H, 0
		ADD HL, HL 							;*10=FONT_HEIGHT
		ADD HL, HL
		ADD HL, HL
		LD E, A
		LD D, 0
		ADD HL, DE
		ADD HL, DE
		LD D, 0x37
		CALL LCD_WR_COM
		LD D, H 							;NEW TOP SCROLL LINE BYTES HIGH (1-480)
		CALL LCD_WR_DAT
		LD D, L 							;NEW TOP SCROLL LINE BYTES LOW
		CALL LCD_WR_DAT
		RET
		
;CLEAR A LINE FOR TEXT A IS THE LINE 0-47
@LCD_CLRTXTLN:	LD DE, 0
;PARAM1
		PUSH DE
		LD L, A
		LD H, 0
		ADD HL, HL 							;*10=FONT_HEIGHT
		ADD HL, HL
		ADD HL, HL
		LD E, A
		LD D, 0
		ADD HL, DE
		ADD HL, DE
;PARAM2
		PUSH HL
		LD DE, FONT_HEIGHT
		ADD HL, DE
;PARAM4
		EX DE, HL
		LD HL, LCD_WIDTH
;PARAM3
		PUSH HL
		PUSH DE 							;PARAM4
		CALL LCD_SETXY
		LD BC, 8000 							; LCD_WIDTH * FONT_HEIGHT ;8000 BYTES 800*10
		LD HL, (BCOLOR)
CTL_AGN:	CALL LCD_SETPIXEL 						;DESTROYS D,A
		DEC BC
		LD A, B
		OR C
		JR NZ, CTL_AGN
		CALL LCD_CLRXY
		RET
		
		
PRCH_NEWLN:	
		XOR A
		LD (HL), A
		INC HL
		LD A, (HL)
		INC A
;CHECK FOR END OF SCREEN
		CP 48 								;47 LINES MAX THEN WRAP OR BETTER SCROLL THE SCREEN!!!
		JR Z, PRCH_SCROLL
		LD (HL), A
		RET
;SCROLL
PRCH_SCROLL:	PUSH AF
		PUSH HL
;CLEAR NEW LINE
		LD A, (SCRLN)
		CALL LCD_CLRTXTLN
		
		CALL LCD_DOSCROLL
		POP HL
		POP AF
;XOR A
		DEC A
		LD (HL), A 							;CURSORY
		XOR A
		LD (CURSORX), A
		RET
		
		
;
@LCD_RMVCURS:	
;REMOVES THE CURSOR FROM PREVIOUS POSITION
;   LD A,(CURSORX)
;   LD H,A
;   LD A,(CURSORY)
;   LD L,A
;   PUSH HL             ;SAVE CURSOR
;   LD A,(PRECSRX)     ;REPLACE CURSX AND Y WITH THE PREVIOUS ONES
;   LD (CURSORX),A
;   LD A,(PRECSRY)
;   LD (CURSORY),A
		LD HL, (BCOLOR) 						;
		JR LCD_SETCURS
;   POP HL              ;LOAD CURSOR
;   LD A,H
;   LD (CURSORX),A
;   LD A,L
;   LD (CURSORY),A
;  RET
		
		
@LCD_PRNCURS:	
;ADD A CURSOR ON NEW POSITION
		LD HL, (FCOLOR) 						;COLOR PARAM
		
@LCD_SETCURS:	
		PUSH HL 							;COLOR PARAM
		LD A, (CURSORX)
		LD B, FONT_WIDTH
		LD D, 0
		LD E, A
		LD HL, 0
		OR A 								;CLEAR CARRY
SCUR_AGN1:	
		ADC HL, DE
		DJNZ SCUR_AGN1 							;HL = DE * B
		PUSH HL 							;1ST PARAM X1
		LD BC, FONT_WIDTH
		ADC HL, BC 							;NEXT CHAR
		DEC HL 								;MINUS 1
		PUSH HL 							;SAVE 3RD PARAM X2
;LD A,(CURSORY)
		CALL LCD_CALCLINE
		LD B, FONT_HEIGHT
		LD D, 0
		LD E, A
		LD HL, 0
SCUR_AGN2:	
		ADC HL, DE
		DJNZ SCUR_AGN2 							;HL=B*DE
		LD C, FONT_HEIGHT - 2 						;2 PIXEL HEIGTH CURSOR
		LD B, 0
		ADC HL, BC 							;ADD FONT_HEIGHT-2 PIXELS
		POP DE 								;RETREIVE 3RD PARAM ON DE
		PUSH HL 							;2ND PARAM Y1
		PUSH DE 							;3RD PARAM X2
;INC HL
		INC HL 								; Y2 ADD THE LAST +2 PIXELS
		PUSH HL 							;4TH PARAM Y2
		CALL LCD_SETXY
;SEND THE PIXELS = 2*FONT_WIDTH
		POP HL 								;GET THE COLOR
		LD B, 2 * FONT_WIDTH 						;2*8=16
SCUR_AGN3:	
		CALL LCD_SETPIXEL 						;DESTROYS D,A
		DJNZ SCUR_AGN3
;LD A,(CURSORX)
;LD (PRECSRX),A      ; SAVE CURSOR TO PREVIOUSX
;LD A,(CURSORY)
;LD (PRECSRY),A      ; SAVE CURSOR TO PREVIOUSX
		RET

;LCD CLEAR SCREEN		
@LCD_CLRSCR:	
		CALL LCD_CLRXY 							;
		LD HL, (BCOLOR)
; JP METH2
		LD BC, LCD_HEIGHT + 1
CS_AGNA2:	PUSH BC
		LD BC, LCD_WIDTH + 1
CS_AGNA1:	CALL LCD_SETPIXEL 						;DESTROYS D,A, HL HAS COLOR INFO
		DEC BC
		LD A, B
		OR C
		JR NZ, CS_AGNA1
		POP BC
		DEC BC
		LD A, B
		OR C
		JR NZ, CS_AGNA2
		LD HL, 0 							;RESET CURSOR AT 0,0
		LD (CURSORX), HL
		RET
		
;METHOD2 FOR CLEAR SCREEN NOT USED		
METH2:		
;OUTER LOOP HEIGHT TIMESS
		LD B, LCD_HEIGHT.AND.0xFF 					;lsb
		LD C, LCD_HEIGHT.SHR.8 + 1 					;MSB+1
CS_AGN2:	
		PUSH BC
;INNER LOOP WIDTH TIMES
		LD B, LCD_WIDTH.AND.0xFF 					;lsb
		LD C, LCD_WIDTH.SHR.8 + 1 					;MSV+1
CS_AGN1:	
		CALL LCD_SETPIXEL 						;DESTROYS D,A, HL HAS COLOR INFO
		DJNZ CS_AGN1
		DEC C
		JR NZ, CS_AGN1
		POP BC
		DJNZ CS_AGN2
		DEC C
		JR NZ, CS_AGN2
		LD HL, 0 							;RESET CURSOR AT 0,0
		LD (CURSORX), HL
		RET
		
		
;PRINT A MESSAGE AT CURSOR
;HL HAS THE ZERO TERMINATED TEXT BUFFER
@LCD_MSG:	LD A, (HL)
		CP 0
		RET Z
		PUSH HL
		CALL LCD_PRINTCHAR
		POP HL
		INC HL
		JR LCD_MSG
