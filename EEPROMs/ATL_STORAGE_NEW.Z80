	NAME STORAGE_NEW_USB_SDCARD

;STORAGE COMMANDS
		GLOBAL STRG_INIT
		GLOBAL STRG_OPENCRD
		GLOBAL STRG_OPNFILE
		GLOBAL STRG_CLSFILE
		GLOBAL STRG_DIRLIST
		GLOBAL STRG_DIRCHG
		GLOBAL STRG_DIRNMCHG
		GLOBAL STRG_OPENCDIR
		GLOBAL STRG_BLKREAD
		GLOBAL STRG_BLKWRITE
		GLOBAL STRG_TPFILE
		GLOBAL STRG_GETPOS
		GLOBAL STRG_SETPOS
		GLOBAL STRG_SETPOS16
		GLOBAL STRG_GETSIZE
		GLOBAL STRG_GETEOF
		GLOBAL STRG_PRDRVINFO
		GLOBAL STRG_LOADFILE
		GLOBAL STRG_SAVEFILE
		GLOBAL STRG_CHECK
		GLOBAL STRG_EXISTS		
		GLOBAL STRG_DIRLIST
		GLOBAL STRG_DIRCHG
		GLOBAL STRG_READBUFR
		GLOBAL STRG_WRITEBUFR
		;COPYFNAME on ATL_UTILS fname goes to strgbuff


@CH376_ERROR EQU RS_MESG



;INITIALIZE THE CH376S
;A=3 FOR SDCARD, 6 FOR USB FLASH
;RETURNS THE VERSION ON A IF ALL OK
;A=0 IF ERROR OR DEVICE NOT PRESENT
;ALSO CHECK THE ZF NZ=ERROR
;DESTROYS D
STRG_INIT:	LD D,A
		XOR A		
		LD (STRG_STAT),A 	;NOT CONNECTED, NOT EXISTS
		CALL CH376_INIT
		JR NZ,INIERR
		LD A,D			;SELECT USB DEVICE 3 FOR SDCARD, 6 FOR FLASH
		CALL CH376_SETUSB
		JR Z,INIOK
INIERR:		LD A,0		
		RET
INIOK:		CALL CH376_VERSION
		CP A		;SET ZF
		LD A, $80		;BIT 7 MEANS EXISTS
		LD (STRG_STAT),A 	;
		RET

;NZ IF EXISTS
STRG_EXISTS:	LD A,(STRG_STAT)
		BIT 7,A
		RET

;CHECKS IF USB IS CONNECTED OR DISCONNECTED AND CONNECTS IF NECESSARY
;CAN BE CALLED MULTIPLE TIMES ONLY ONCE THE DRIVE IS MOUNTED
;CF SET IF DEVICE NOT PRESENT
;A=0 TIMEOUT, A=1 IF JUST CONNECTED,A=2 IF JUST DISCONNECTED
STRG_CHECK:	CALL STRG_EXISTS
		SCF
		RET Z				;Z MEANS NOT EXISTS
		LD B,5
SC_AGN1:	CALL CH376_CONNECT		
		JR Z,DOCON
		JR NC,DODISC
		DJNZ SC_AGN1				
		;CALL RS_MESG
		;DEFM " TIMEOUT CONNECTING"
		;DB 10,13,0
		XOR A			
		RET 		;TIMEOUT
		
DOCON:		XOR A				;CLCF
		LD A,(STRG_STAT)
		BIT 0,A
		RET NZ				;ALREADY MOUNTED THE DRIVE
		;CALL RS_MESG
		;DEFM " MOUNTING"
		;DB 10,13,0					
		CALL CH376_MOUNT			;MOUNT THE DRIVE
		JR NZ, DONOMNT
		;CALL RS_MESG
		;DEFM " CONNECT"
		;DB 10,13,0		
		LD A,(STRG_STAT)
		SET 0,A
		LD (STRG_STAT),A
		XOR A				;CLEAR CARRY FLAG MEANS WE ARE OK
		LD A,1				;A=1 IS JUST CONNECTED
		RET
DONOMNT:	;CALL RS_MESG
		;DEFM " NOT MOUNTED"
		;DB 10,13,0		

DODISC:		;CALL RS_MESG
		;DEFM " DISCONNECT"
		;DB 10,13,0	
		XOR A	
		LD A,(STRG_STAT)		
		BIT 0,A
		RET Z				;ALREADY DISCONNECTED
		RES 0,A				;SET BIT 0 TO 0=DISCONNECTED
		LD (STRG_STAT),A		
		LD A,2				;A=2 IS JUST DISCONNECTED
		RET


;MOUNTS THE FLASH DISK
;IN A=6 USB STICK 3-SDCARD
;NZ IF ERROR
STRG_OPENCRD:   JP CH376_MOUNTDEV		


SDIRTP 		DEFB '*',0
;OUTPUTS CURRENT DIRECTORY ON SCREEN
STRG_DIRLIST:	CALL STRG_OPENCDIR	;OPEN CURRENT DIR
		LD HL,SDIRTP
		CALL STRG_OPENFD
DL_NXTFILE:	RET Z 			;NO  MORE FILES
		LD A,CMD_RDUSB_DATA0
		CALL CH376_COMMD
		CALL CH376_GETDATA	;DATA ON USBBUF A=BYTES TO READ
		LD A,0
		LD (DE),A   ;ZT STRING
		;PRINT DATA ON USBBUF
		LD HL,USBBUF
		CALL OS_PRMESSCRSFE
		LD A,$0D
		CALL OS_PRCHSCR
		;NEXT FILE
		LD A, CMD_FILEENUM_GO
		CALL CH376_COMMD
		CALL CH376_WTCMDEND
		CP ERR_MISS_FILE
		JR DL_NXTFILE

;HL POINTS TO DIRNAME
;RETURNS AFTER IT
NEXTDIR:	LD A,(HL)
		INC HL
		OR A
		RET Z
		JR NEXTDIR

;OPENS CURRENT DIR ON DIRNM
;DIRNM SHOULD BE /0 1STNAME0...LASTNAME00
;CF SET ON ERROR OR MISSING FILE 
;DESTROYS AF
STRG_OPENCDIR:	PUSH HL
		PUSH DE
		PUSH BC		
		LD HL,DIRNM
		CALL STRG_OPENCDIR2
	        POP BC
		POP DE
		POP HL
		RET

STRG_OPENCDIR2:	LD A,(HL)
		OR A
		RET Z		;WHEN ZERO MEANS NO MORE DIR TO OPEN
	;	PUSH HL
	;	 CALL OS_PRINTTEXT
	;	 POP HL
		PUSH HL
		CALL STRG_OPENFD
		POP HL
		RET C		;ERROR
		SCF
		LD A,150	;MISSING FILENAME
		RET Z		;FILE MISSING
		;OK DIR OPENED
		CALL NEXTDIR
		JR STRG_OPENCDIR2

;HL THE NEW DIR TO ADD OR .. TO GO BACK
;HL PRESERVED
STRG_DIRNMCHG:	PUSH HL		
		LD A,(HL)
		CP '\'								;changed from '/' on 18/2/2024
		JR Z,DNC_RESET
		CP '/'								; 25/2/2024
		JR Z,DNC_RESET		
		CP '.'
		JR NZ, DNC_ADD
		CP '.'
		JR Z,DNC_RMV
		POP HL
		RET	;DO NOTHING IF . OR .\ OR .<x>
DNC_RESET:	LD HL,DIRNM
		LD (HL),'\'
		INC HL
		LD (HL),0
		INC HL
		LD (HL),0
		POP HL
		RET
;REMOVES THE LAST DIRECTORY		
DNC_RMV:	LD HL,DIRNM
		CALL NEXTDIR
		LD A,(HL)
		OR A
		EX DE,HL ;DE THE NEXT DIR
		POP HL
		RET Z	;RET IF WE ARE ON 1ST DIRECTORY		
		PUSH HL
		EX DE,HL ;HL THE NEXT DIR
RMV_NXT:	LD B,H
		LD C,L
		CALL NEXTDIR
		LD A,(HL)
		OR A
		JR NZ,RMV_NXT	;GO TO NEXT DIR 
		;HERE ON THE LAST ONE HL ON THE 2ND ZERO
		;BC THE START OF THE LAST DIR
		XOR A
		LD (BC),A
		POP HL
		RET
DNC_ADD:	EX DE,HL		;DE THE NEW FILE
		LD HL,DIRNM
ADDNXT:		CALL NEXTDIR
		LD A,(HL)
		OR A
		JR NZ,ADDNXT
		;HERE ON THE LAST DIR		
		EX DE,HL
		;COPY FROM HL TO DE
ADDNXT2:	LD A,(HL)
		LD (DE),A
		INC HL
		INC DE
		OR A
		JR NZ,ADDNXT2
		;HERE WE COPIED THE NEW FILE WITH THE ZT
		EX DE,HL
		LD (HL),0 ;SIGNAL END OF DIRECTORIES WITH A SECOND ZERO
		POP HL
		RET
		

;HL THE MESSAGE
TEMPPRMSG:	PUSH AF
		CALL OS_PRMESSCR
		LD A,$0A
		CALL OS_PRCHSCR
		POP AF
		RET

;HL POINTS TO THE ZT STRING
;CF MEANS ERROR SETTING FNAME
;ZF MEANS MISSING FILE
;OPENS A FILE OR DIR
;LD HL, STRGBUFF
;HL PRESERVED
STRG_OPENFD:	
STRG_DIRCHG: 	PUSH HL
		;PUSH HL
		;CALL TEMPPRMSG
		;POP HL
		LD A, CMD_SETFILENAME
    		CALL CH376_COMMD		
    		CALL CH376_WRSTRING
		JR NZ,DC_WSERR		
		LD A, CMD_FILE_OPEN
		CALL CH376_COMMD
		CALL CH376_WTCMDEND			
		POP HL
		CP ERR_MISS_FILE
		RET Z
		OR A		;CLEAR CARRY
		RET
;HERE IF ERROR ON SET FNAME
DC_WSERR:	POP HL
		SCF
		RET		

STRG_TPFILE: 	RET
STRG_GETPOS: 	RET

;MOVE FILE POINTER
;BC:DE BYTES TO MOVE
STRG_SETPOS16:	PUSH DE
		LD DE,0
		CALL STRG_SETPOS 
		POP DE
		RET

STRG_SETPOS: 	LD A,CMD_BYTE_LOCATE
		CALL CH376_COMMD
		LD A,C                             ; 4 BYTES TO SET THE OFFSET LOW IN FRONT
    		CALL CH376_DATAWR
		LD A,B
		CALL CH376_DATAWR
		LD A,E
		CALL CH376_DATAWR	           ;LAST 2 BYTES 0 MAX 65535 SKIP
		LD A,D
		CALL CH376_DATAWR
    		CALL CH376_WTCMDEND
		RET


STRG_GETSIZE: 	RET
STRG_GETEOF: 	RET



;PRINTS TO SCREEN USB DRIVE INFO
;VOLUME NAME , TOTAL SECTORS, FREE SECTORS, FILESYSTEM TYPE
		;VOLUME NAME
STRG_PRDRVINFO:	LD A,CMD_RDUSB_DATA0
		CALL CH376_COMMD
		CALL CH376_GETDATA
		PUSH AF
		SUB 8		
		LD B,A
		POP AF			
		LD HL,USBBUF+8		;SKIP 8 BYTES
PDI_NXT:	LD A,(HL)
		PUSH HL
		PUSH BC
		CALL OS_PRINTCHAR
		POP BC
		POP HL
		INC HL
		DJNZ PDI_NXT		
		CALL RS_NEWLINE
		; SECTORS FREE AND USED
		LD A,CMD_DISK_QUERY  	
		CALL CH376_COMMD
		CALL CH376_WTCMDEND
		RET NZ
		LD A,CMD_RDUSB_DATA0
		CALL CH376_COMMD		
		CALL CH376_GETDATA
		
		LD IX,USBBUF	
		PUSH IX			
		LD D,(IX+3)
		LD E,(IX+2)
		LD H,(IX+1)
		LD L,(IX+0)
		CALL B2D32				;DE:HL RES ON B2DBUF
		LD HL,B2DBUF
		CALL SKIPSPC
		CALL OS_PRINTTEXT
		CALL OS_PRINTMSG
		DEFM " SECTORS"
		DB 10,13 0
		POP IX

		PUSH IX					
		LD D,(IX+7)
		LD E,(IX+6)
		LD H,(IX+5)
		LD L,(IX+4)		
		CALL B2D32		;DE:HL RES ON B2DBUF
		LD HL,B2DBUF
		CALL SKIPSPC
		CALL OS_PRINTTEXT
		CALL OS_PRINTMSG
		DEFM " SECTORS FREE   "
		DB 10,13,0			
		POP IX
		;FILESYSTEM TYPE		
FILESYSTEM:	LD A,(IX+8)		;1-FAT12,2-FAT16,3-FAT32
		DEC A
		JR Z,PDI_NXT0
		DEC A
		JR Z,PDI_NXT1
		DEC A
		JR Z,PDI_NXT2
		JR PDI_NXT3
		;1-FAT12		
PDI_NXT0:	CALL OS_PRINTMSG
		DEFM "FS IS FAT-12"
		DB 10,13,0
		RET
PDI_NXT1:	CALL OS_PRINTMSG
		DEFM "FS IS FAT-16"
		DB 10,13,0
		RET
PDI_NXT2:	CALL OS_PRINTMSG
		DEFM "FS IS FAT-32"
		DB 10,13,0
		RET
PDI_NXT3:	CALL OS_PRINTMSG
		DEFM "UNKNOWN FS"
		DB 10,13,0
		LD A,(IX+8)		;TO BE PRINTED MAYBE
		RET


;OPEN A FILE WITH ITS NAME ON STRGBUFF
;A=0 FOR READ, 1 FOR WRITE, 2 FOR READ/WRITE, 4 FOR CREATE/WRITE
STRG_OPNFILE:	PUSH AF
		LD A, CMD_SETFILENAME
    		CALL CH376_COMMD
		LD HL, STRGBUFF
    		CALL CH376_WRSTRING
		JR Z,OF_WSOK
		POP AF
		CALL OS_PRINTMSG
		DEFM "ERROR SETTING FILENAME"
		DB 10,13,0		
		RET
OF_WSOK:	POP AF
		;PUSH AF
		;CALL PRINTNUM
		;POP AF		
		OR A		;0 READ
		JR Z,OF_OPEN
		SUB 1		;1 WRITE
		JR Z,OF_OPEN
		SUB 1		;2 READ/WRITE
		JR Z,OF_OPEN
		;SUB 1		;3 CREATE AS 4
		;JR Z,OF_CREATE
		;SUB 1		;4 CREATE
		;JR NZ,OF_OPEN	;OTHER JUST OPEN
		;3-255 CREATE
OF_CREATE:	;CALL OS_PRINTMSG
		;DB 10,13
		;DEFM "CREATING..."
		;DB 10,13,0				
		LD A, CMD_FILE_CREATE		
		JR OF_EXEC
OF_OPEN:	;CALL OS_PRINTMSG
		;DB 10,13
		;DEFM "OPENING..."
		;DB 10,13,0	
		LD A, CMD_FILE_OPEN
OF_EXEC:	;PUSH AF
		;CALL PRINTNUM
		;POP AF
		CALL CH376_COMMD
		CALL CH376_WTCMDEND
		RET

STRG_CLSFILE:	LD A, CMD_FILE_CLOSE
    		CALL CH376_COMMD
    		LD A, 1                             ; 1 = update file size if necessary
    		CALL CH376_DATAWR
    		CALL CH376_WTCMDEND
    		RET

;BC THE REQUESTED BYTES
;DE THE DESTINATION BUFFER
;RET HL,BC= BYTES RECEIVED
;ZF OK , NZ ERROR
STRG_BLKREAD:	PUSH DE
		LD A, CMD_BYTE_READ
    		CALL CH376_COMMD
    		LD A, C                           ; BYTES REQUEST ON BC
    		CALL CH376_DATAWR
    		LD A, B
    		CALL CH376_DATAWR
		CPL
		CPL				
		;CALL OS_PRINTMSG
		;DEFM "BLOCK READING"
		;DB 10,13,0
		POP DE
		LD HL,0				  ;BYTE RECEIVE COUNTER
STBR_DOREST:	PUSH HL
		PUSH DE
		CALL CH376_WTCMDEND
		POP DE
		POP HL
		JR Z, FR_DONE	  ;Z=NO MORE OR CANNOT READ
		CP USB_INT_DISK_READ                    
    		JR NZ, FR_ERROR
		;OK READ THE BYTES
		LD A,CMD_RDUSB_DATA0
		CALL CH376_COMMD	
		CALL CH376_DATARD		;A= BYTES TO READ TO BUFFER
		LD B,A
		;PUSH HL
		;PUSH DE
		;PUSH BC
		;PUSH AF
		;CALL OS_PRINTMSG
		;DEFM "READING "
		;DB 0	
		;POP AF	
		;CALL PRINTNUM
		;POP BC
		;POP DE
		;POP HL
STBR_NXT1:	CALL CH376_DATARD		;READ THE BYTES TO BUFFER
		LD (DE),A
		INC DE
		INC HL				;TOTAL BYTES READ COUNTER
		DJNZ STBR_NXT1		
		LD A, CMD_BYTE_RD_GO	
		CALL CH376_COMMD	
		JR STBR_DOREST
FR_DONE:	;PUSH HL
		;CALL OS_PRINTMSG
		;DEFM "READING DONE!!! "
		;DB 0	
		;POP HL
		LD B,H
		LD C,L
		XOR A
		RET
FR_ERROR:	PUSH AF
		CALL PRINTNUM
		CALL OS_PRINTMSG
		DEFM "ERROR READING BLOCK!!! "
		DB 0	
		POP AF
		LD B,2
		DEC B
		RET		

;LOADS A FILE TO MEM
;HL THE FILE
;BC THE BYTE COUNT TO LOAD
;DE THE BUFFER TO PUT THE BYTES
;RET CF IF ERROR & BC BYTES LOADED TO BUFFER
STRG_LOADFILE:	PUSH DE
		PUSH BC
		;PUSH HL		
		;CALL OS_PRINTMSG
		;DEFM "OPEN FILE"
		;DB 10,13,0
		;POP HL
		CALL COPYFNAME
		XOR A			;READ ONLY 
		CALL STRG_OPNFILE		
		JR NZ, FOPENERR
		;CALL OS_PRINTMSG
		;DB 10,13
		;DEFM "FILE OPEN OK"
		;DB 10,13,0		
		POP BC		;BYTECOUNT
		POP DE		;DEST BUFFER
		CALL STRG_BLKREAD
		JR Z, FREADOK
		CALL PRINTNUM
		CALL OS_PRINTMSG
		DEFM " ERROR READING FILE"
		DB 10,13,0
		PUSH DE
		PUSH BC
		JR FOPENERR
FREADOK:	PUSH BC
		CALL B2D16
		LD HL,B2DBUF
		CALL SKIPSPC
		CALL RS_TXT
		CALL OS_PRINTMSG
		DEFM " BYTES READ"
		DB 10,13,0
		CALL STRG_CLSFILE
		POP BC			;BYTES LOADED TO BUFFER
		XOR A
		RET
FOPENERR:	POP BC
		POP DE
		CALL PRINTNUM
		CALL OS_PRINTMSG
		DEFM "-->ERROR AT LOADFILE"
		DB 10,13,0
		LD HL,STRGBUFF
		CALL RS_TXT
		CALL RS_NEWLINE
		SCF
		RET


;READS A BYTE FROM FILE TO MEM
;HL ZT FILENAME
;BC THE OFFSET OF THE BYTE TO READ
;DE THE BUFFER TO PUT THE BYTE (500 BYTES LENGTH)
;RET CF IF ERROR & BC BYTES LOADED TO BUFFER
STRG_READBUFR:	PUSH DE
		PUSH BC
		;PUSH HL		
		;CALL OS_PRINTMSG
		;DEFM "OPEN FILE"
		;DB 10,13,0
		;POP HL
		CALL COPYFNAME
		XOR A			;READ ONLY 
		CALL STRG_OPNFILE		
		JR NZ, RB_FOPENERR
		;CALL OS_PRINTMSG
		;DB 10,13
		;DEFM "FILE OPEN OK"
		;DB 10,13,0		
		POP BC		;BYTE OFFSET
		CALL STRG_SETPOS16
		LD BC, 500	;READ 500 BYTES		
		POP DE		;DEST BUFFER
		CALL STRG_BLKREAD
		JR Z, RB_FREADOK
		CALL PRINTNUM
		CALL OS_PRINTMSG
		DEFM " ERROR READING FILE"
		DB 10,13,0
		JR RB_FOPENERR2
RB_FREADOK:	PUSH BC
		;CALL B2D16
		;LD HL,B2DBUF
		;CALL SKIPSPC
		;CALL RS_TXT
		;CALL OS_PRINTMSG
		;DEFM " BYTES READ"
		;DB 10,13,0
		CALL STRG_CLSFILE
		POP BC			;BYTES LOADED TO BUFFER
		XOR A
		RET
RB_FOPENERR:	POP BC
		POP DE
RB_FOPENERR2:	CALL PRINTNUM
		CALL OS_PRINTMSG
		DEFM "-->ERROR OPENING FILE"
		DB 10,13,0
		LD HL,STRGBUFF
		CALL RS_TXT
		CALL RS_NEWLINE
		SCF
		RET


;BC THE BYTES TO WRITE 
;DE THE SOURCE BUFFER OF BYTES TO BE WRITTEN
STRG_BLKWRITE:  PUSH DE
		LD A, CMD_BYTE_WRITE
    		CALL CH376_COMMD
    		LD A, C                           ; BYTES REQUEST ON BC
    		CALL CH376_DATAWR
    		LD A, B
    		CALL CH376_DATAWR				
		;CALL OS_PRINTMSG
		;DEFM "BLOCK WRITING"
		;DB 10,13,0
		POP HL
STBW_DOREST:	CALL CH376_WTCMDEND		
		JR Z, WFR_DONE	  ;Z=NO MORE OR CANNOT READ
		CP USB_INT_DISK_WRITE                    
    		JR NZ, WFR_ERROR
		LD A,CMD_WR_REQ_DATA
		CALL CH376_COMMD	
		;READ BYTE COUNT 		
		CALL CH376_DATARD	;READ BYTE COUNT UP TO 255 BYTES
		LD B,A			

STBW_NXT1:	LD A,(HL)
		CALL CH376_DATAWR
		INC HL
		DJNZ STBW_NXT1
		LD A, CMD_BYTE_WR_GO	
		CALL CH376_COMMD	
		JR STBW_DOREST
WFR_DONE:	;PUSH HL
		;CALL OS_PRINTMSG
		;DEFM "WRITING DONE!!! "
		;DB 13,10,0	
		;POP HL
		OR A
		RET
WFR_ERROR:	PUSH AF
		CALL PRINTNUM
		CALL OS_PRINTMSG
		DEFM "ERROR WRITING BLOCK!!! "
		DB 13,10,0	
		POP AF
		LD B,2
		DEC B
		RET		


;SAVES A FILE FROM MEM
;HL THE FILE
;BC THE BYTE COUNT TO SAVE
;DE THE BUFFER TO GET THE BYTES
;RET CF IF ERROR & BC BYTES SAVED TO FILE
STRG_SAVEFILE:	PUSH DE
		PUSH BC
		PUSH HL		
		CALL OS_PRINTMSG
		DB 10,13
		DEFM "SAVE FILE"
		DB 10,13,10,13,0
		POP HL
		CALL COPYFNAME
		LD A,4			;CREATE THE FILE
		CALL STRG_OPNFILE		
		JR NZ, FSAVEERR
		CALL OS_PRINTMSG
		DB 10,13
		DEFM "FILE CREATED OK"
		DB 10,13,0
		POP BC		;BYTECOUNT
		POP DE		;SOURCE BUFFER
		CALL STRG_BLKWRITE
		JR Z, FWRITEOK
		;CALL PRINTNUM
		CALL OS_PRINTMSG
		DEFM " ERROR WRITING FILE"
		DB 10,13,0
FWRITEOK:	CALL OS_PRINTMSG
		DEFM "BYTE WRITTEN"
		DB 10,13,0
		CALL STRG_CLSFILE
		XOR A
		RET
FSAVEERR:	POP BC
		POP DE
		CALL PRINTNUM
		CALL OS_PRINTMSG
		DEFM "-->ERROR CREATING FILE"
		DB 10,13,0
		LD HL,STRGBUFF
		CALL RS_TXT
		CALL RS_NEWLINE
		SCF
		RET


;WRITES 500 BYTES FROM A BUFFER TO THE END OF THE FILE
;HL POINTS THE FILENAME
;DE THE BUFFER
;BC THE BYTECOUNT
;CF ON FILEOPEN/CREATE ERROR
;NZ ON WRITE TO FILE ERROR
;ZF ON SUCCESS
STRG_WRITEBUFR:	PUSH BC
		PUSH DE
		CALL COPYFNAME			;HL NOT NEEDED AFTER THIS
		LD A,1				;OPEN THE FILE FOR W
		CALL STRG_OPNFILE		
		JR NZ,SWB_CREATE		;ON ERROR TRY TO CREATE THE FILE
		;APPEND
		LD BC,$FFFF
		LD DE,$FFFF	
		CALL STRG_SETPOS		;GOTO EOF
		JR SWB_WRITEBUF
SWB_CREATE:	;CREATE THE FILE
		LD A,4
		CALL STRG_OPNFILE		
		LD A,151			;ERROR NUMBER
		JR NZ, SWB_ERR
SWB_WRITEBUF:	POP DE
		POP BC				;THE BYTE COUNT		
		CALL STRG_BLKWRITE		
		PUSH AF
		CALL STRG_CLSFILE		;ALWAYS CLOSE FILE
		POP AF
		RET NZ				;NZ IF ERROR
		XOR A
		RET
SWB_ERR:	POP DE
		POP BC		
		SCF
		RET		